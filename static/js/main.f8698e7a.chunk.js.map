{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","index.ts","conway.ts"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_slicedToArray","isArray","Symbol","iterator","Object","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","err","o","minLen","n","prototype","toString","call","slice","constructor","name","from","test","TypeError","document","addEventListener","playing","game","size","cells","Uint8Array","clear","index","setCell","eachNeighbor","incrementNeighborCount","clearCell","decrementNeighborCount","getCoordFromIndex","Math","floor","operation","x","y","getIndexFromCoord","wrapAroundSize","coord","getNextState","currentState","neighborCount","debug","console","log","map","cell","raw","rawBits","state","draw","canvas","context","getContext","cellHeight","height","cellWidth","width","clearRect","forEach","row","column","fillRect","clone","nextState","randomize","round","random","Conway","getElementById","toggleButton","textContent","window","requestAnimationFrame","compute"],"mappings":"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","file":"static/js/main.f8698e7a.chunk.js","sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import Conway from './conway';\nimport './index.css';\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  let playing = false;\n\n  const game = Conway(250);\n  game.randomize();\n\n  const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n  game.draw(canvas);\n\n  const toggleButton = document.getElementById('toggle') as HTMLButtonElement;\n  toggleButton.addEventListener('click', function () {\n    // The toggle button was clicked, so determine if we should start or stop the game from running.\n    if (playing) {\n      // The game was running, so stop everything.\n      playing = false;\n      toggleButton.textContent = 'Start';\n    } else {\n      // The game wasn't running, so start it up.\n      playing = true;\n      toggleButton.textContent = 'Stop';\n\n      function compute() {\n        if (!playing) { return; }\n        game.next();\n        game.draw(canvas);\n        window.requestAnimationFrame(compute);\n      }\n\n      window.requestAnimationFrame(compute);\n    }\n  });\n});\n","export default function Conway(size: number) {\n  // Our cells. Each is a byte that represents the following:\n  //\n  // 7 6 5 4 3 2 1 0\n  // ┗━┳━┛ ┗━━┳━━┛ ┗━ Cell state. 1 is on, 0 is off\n  //   ┃      ┗━━━━━━ Number of on neighbors (0-8)\n  //   ┗━━━━━━━━━━━━━ Not used\n  //\n  const cells = new Uint8Array(size * size);\n\n  /**\n   * Log the cells to the console. Useful for debugging.\n   */\n  function debug() {\n    console.log(Array.from(cells).map(function (cell) {\n      return {\n        raw: cell,\n        rawBits: cell.toString(2),\n        state: cell & 1,\n        neighborCount: cell >>> 1,\n      };\n    }));\n  }\n\n  /**\n   * Draw an iteration of the game of life.\n   */\n  function draw(canvas: HTMLCanvasElement): void {\n    const context = canvas.getContext('2d')!;\n\n    // Figure out how big we need to draw each cell.\n    const cellHeight = Math.floor(canvas.height / size);\n    const cellWidth = Math.floor(canvas.width / size);\n\n    // Erase everything.\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw each cell. We only need to stop for live cells.\n    cells.forEach(function (cell, index) {\n      // If the cell is on, draw it. For the cell to be on the first bit must be 1.\n      if ((cell & 1) === 1) {\n        const [row, column] = getCoordFromIndex(index);\n        const x = row * cellWidth;\n        const y = column * cellHeight;\n        context.fillRect(x, y, cellWidth, cellHeight);\n      }\n    });\n  }\n\n  /**\n   * Turn all cells off.\n   */\n  function clear(): void {\n    for (let index = 0; index < cells.length; index++) {\n      cells[index] = 0;\n    }\n  }\n\n  /**\n   * Erase everything and fill with random data.\n   */\n  function randomize(): void {\n    // Zero out each cell. This sets the neighbor count to 0, which makes it easier to randomize\n    // and update the neighbor count.\n    clear();\n\n    // Randomize and update neighbor counts.\n    for (let index = 0; index < cells.length; index++) {\n      const value = Math.round(Math.random());\n\n      if (value) {\n        setCell(index);\n      }\n    }\n  }\n\n  /**\n   * Generate the next iteration.\n   */\n  function next() {\n    const clone = new Uint8Array(cells);\n\n    for (let index = 0; index < clone.length; index++) {\n      const cell = clone[index];\n      const currentState = cell & 1;\n      const neighborCount = cell >>> 1;\n\n      // Update the cell if there's a possibility it has changed.\n      if (currentState || neighborCount) {\n        const nextState = getNextState(currentState, neighborCount);\n\n        if (nextState !== currentState) {\n          if (nextState) {\n            setCell(index);\n          } else {\n            clearCell(index);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Turn a cell on.\n   */\n  function setCell(index: number): void {\n    // Set the state to on.\n    cells[index] |= 1;\n    // Update neighboring neighbor counts.\n    eachNeighbor(incrementNeighborCount, index);\n  }\n\n  /**\n   * Turn a cell off.\n   */\n  function clearCell(index: number): void {\n    // Set the state to off.\n    cells[index] &= ~1;\n    // Update neighboring neighbor counts.\n    eachNeighbor(decrementNeighborCount, index);\n  }\n\n  /**\n   * Convert a 1-dimensional array index to a 2-dimensional row and column.\n   */\n  function getCoordFromIndex(index: number): [x: number, y: number] {\n    return [\n      index % size,\n      Math.floor(index / size),\n    ];\n  }\n\n  /**\n   * Perform some operation on all 8 cells around an index.\n   */\n  function eachNeighbor(operation: (index: number) => void, index: number): void {\n    const [x, y] = getCoordFromIndex(index);\n    operation(getIndexFromCoord(wrapAroundSize(x - 1), wrapAroundSize(y - 1)));\n    operation(getIndexFromCoord(wrapAroundSize(x - 1), y));\n    operation(getIndexFromCoord(wrapAroundSize(x - 1), wrapAroundSize(y + 1)));\n    operation(getIndexFromCoord(x,                     wrapAroundSize(y - 1)));\n    operation(getIndexFromCoord(x,                     wrapAroundSize(y + 1)));\n    operation(getIndexFromCoord(wrapAroundSize(x + 1), wrapAroundSize(y - 1)));\n    operation(getIndexFromCoord(wrapAroundSize(x + 1), y));\n    operation(getIndexFromCoord(wrapAroundSize(x + 1), wrapAroundSize(y + 1)));\n  }\n\n  /**\n   * Increment the neighbor count of a cell.\n   */\n  function incrementNeighborCount(index: number): void {\n    cells[index] += 0b10;\n  }\n\n  /**\n   * Decrement the neighbor count of a cell.\n   */\n  function decrementNeighborCount(index: number): void {\n    cells[index] -= 0b10;\n  }\n\n  /**\n   * Convert a 2-dimensional row and column into a 1-dimensional index.\n   */\n  function getIndexFromCoord(x: number, y: number): number {\n    return x + y * size;\n  }\n\n  /**\n   * Wrap a row or column number around the height/width of the game.\n   */\n  function wrapAroundSize(coord: number): number {\n    if (coord < 0) {\n      return size - 1;\n    }\n    if (coord >= size) {\n      return 0;\n    }\n    return coord;\n  }\n\n  /**\n   * Get the next cell state based on the current state and number of neighbors. This is what makes\n   * this Conway's Game of Life.\n   */\n  function getNextState(currentState: number, neighborCount: number) {\n    switch (neighborCount) {\n      case 3:\n        return 1;\n      case 2:\n        return currentState;\n      default:\n        return 0;\n    }\n  }\n\n  return { clear, debug, draw, next, randomize};\n}\n"],"sourceRoot":""}